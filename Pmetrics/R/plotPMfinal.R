#' Plot PMfinal objects
#'
#' If \code{formula} is omitted, this will generate a marginal plot for each parameter.  
#' For NPAG data, this will be a histogram of marginal values for each parameter and the associated probability
#' of that value.  For IT2B, this will be a series of normal distributions with mean and standard deviation
#' equal to the mean and standard deviation of each parameter marginal distribution, and the standard deviation and 95% distribution
#' indicated at the bottom of each plot.  IF \code{formula} IS specified,
#' this will generate a bivariate plot.  For NPAG data, it will be support point with size proportional to the probability
#' of each point.  For IT2B, it will be an elliptical distribution of a bivariate normal distribution centered at the mean
#' of each plotted variable and surrounding quantiles of the bivariate distribution plotted in decreasing shades of grey.
#' 
#' @title Plot Pmetrics Final Cycle Parameter Value Distributions
#' @method plot PMfinal
#' @param x The name of an \emph{PMfinal} data object generated by \code{\link{makeFinal}}
#' @param formula An optional formula of the form \code{y ~ x}, where \code{y} and \code{x}
#' are two model parameters to plot in a 3-dimensional bivariate plot.  See details.
#' @param cex.lab Size of the plot labels for any univariate or bivariate marginal plot.
#' @param col This parameter will be applied to the histogram lines of a univariate marginal
#' plot, or the central point of a bivariate plot and is \dQuote{red} by default for the former, 
#' and \dQuote{white} for the latter.
#' @param pch The plotting character for points in bivariate plots.  Default is a cross (pch=3).
#' @param cex The size of the points in bivariate plots
#' @param lwd Width of the histogram lines in the univariate marginal parameter distributions
#' or the thickness of the central points and lines around points in bivariate NPAG plots or around quantiles in the bivariate
#' IT2B plots.
#' @param density Boolean operator to plot a kernel density function overlying the histogram
#' of a univarite marginal parameter distribution from NPAG; the default is \code{False}.
#' See \code{\link{density}}.  Ignored for IT2B output.
#' @param scale How large to scale the points in a bivariate NPAG plot, relative to their probability.
#' Ignored for IT2B output.
#' @param bg Background fill for points in bivariate NPAG plot.  Ignored for IT2B output.
#' @param standard Standardize the normal parameter distribution plots from IT2B to the same
#' scale x-axis.  Ignored for NPAG output.
#' @param probs Vector of quantiles to plot on bivariate IT2B plot.  Ignored for NPAG plot.
#' @param legend Boolean operator for default if \code{True} or list of parameters to be supplied to legend function to plot 
#' quantile legend on bivariate IT2B plot.  Ignored for NPAG plot.
#' @param grid Boolean operator to plot a grid on either a bivariate NPAG or IT2B plot.
#' @param xlab Define x-axis label for bivariate NPAG or IT2B plot.  Default is the name of the plotted x-variable.
#' @param ylab Define y-axis label for bivariate NPAG or IT2B plot.  Default is the name of the plotted y-variable.
#' @param xlim Limits for the x-axis in a bivariate NPAG or IT2B plot.  Default is the range of the x-variable.
#' @param ylim Limits for the y-axis in a bivariate NPAG or IT2B plot.  Default is the range of the y-variable.
#' @param out Direct output to a PDF, EPS or image file.  Format is a named list whose first argument, 
#' \code{type} is one of the following character vectors: \dQuote{pdf}, \dQuote{eps} (maps to \code{postscript}),
#' \dQuote{\code{png}}, \dQuote{\code{tiff}}, \dQuote{\code{jpeg}}, or \dQuote{\code{bmp}}.  Other named items in the list
#' are the arguments to each graphic device. PDF and EPS are vector images acceptable to most journals
#' in a very small file size, with scalable (i.e. infinite) resolution.  The others are raster images which may be very
#' large files at publication quality dots per inch (DPI), e.g. 800 or 1200. Default value is \code{NA} which means the 
#' output will go to the current graphic device (usually the monitor). For example, to output an eps file,
#' out=list(\dQuote{eps}) will generate a 7x7 inch (default) graphic.
#' @param \dots Other parameters as found in \code{\link{plot.default}}.
#' @return Plots the object.
#' @author Michael Neely
#' @seealso \code{\link{makeFinal}}, \code{\link{plot}}, \code{\link{par}}, \code{\link{axis}}
#' @export
#' @examples
#' data(PMex1)
#' plot(final.1)




plot.PMfinal <- function(x,formula,cex.lab=1.2,col,pch,cex,lwd,density=F,scale=100,bg,standard=F,
                         probs=c(0.05,0.25,0.5,0.75,0.95),legend=T,grid=T,xlab,ylab,xlim,ylim,out=NA,...){
  #choose output
  if(inherits(out,"list")){
    if(out$type=="eps") {setEPS();out$type <- "postscript"}
    if(length(out)>1) {do.call(out$type,args=out[-1])} else {do.call(out$type,list())}
  }
  
  if(missing(formula)){ #univarite plot
    data <- x
    if(missing(col)) col <- "red"
    if(missing(lwd)) lwd <- 4
    par(mfrow=c(ceiling(length(data$popMean)/3),ifelse(length(data$popMean)>2,3,length(data$popMean))))
    par(mar=c(5,5,4,2)+0.1)
    if(inherits(data,"NPAG")){
      if(missing(ylim)) ylim <- c(0,max(data$popPoints[,"prob"]))
      for (i in 1:(ncol(data$popPoints)-1)){        
        plot(data$popPoints[,"prob"]~data$popPoints[,i],type="h",lwd=lwd,col=col,xlab=names(data$popPoints)[i],xlim=data$ab[i,],
             ylim=ylim,ylab="Probability",cex.lab=cex.lab,...)
        abline(v=data$ab[i,],lty=2,lwd=1,col="black")
        if(density & nrow(data$popPoints)>1){
          den <- density(data$popPoints[,i])
          den$y <- den$y/(max(den$y)/max(data$popPoints[,"prob"]))
          lines(den)
        }
      } 
    }
    if(inherits(data,"IT2B")){
      for (i in 1:(length(data$popMean))){
        x <- seq(data$ab[i,1],data$ab[i,2],(data$ab[i,2]-data$ab[i,1])/1000)
        y <- dnorm(x,mean=data$popMean[i],sd=data$popSD[i])
        if (standard){xlim <- range(data$ab)} else {xlim <- data$ab[i,]}
        plot(x=x,y=y,type="l",lwd=lwd,col=col,xlab=names(data$popMean)[i],xlim=xlim,
             ,ylab="Probability",cex.lab=cex.lab,...)
        abline(v=data$ab[i,],lty=2,lwd=1,col="black")
        abline(v=data$popMean[i],lwd=1,col="black")
        for(j in c(qnorm(0.975),1)){
          lines(x=c(data$popMean[i]-j*data$popSD[i],data$popMean[i]+j*data$popSD[i]),y=c(0,0),lwd=4,col=c("gray80","black")[1+as.numeric(j==1)])
        }
      } 
    }
    par(mfrow=c(1,1))
    par(mar=c(5,4,4,2)+0.1)
    
  } else {  #bivariate plot
    
    data <- x
    keep <- NULL
    yCol <- as.character(attr(terms(formula),"variables")[2])
    xCol <- as.character(attr(terms(formula),"variables")[3])
    if(missing(xlab)) xlab <- xCol
    if(missing(ylab)) ylab <- yCol
    if(missing(pch)) pch <- 3
    if(missing(lwd)) lwd <- 1
    if(missing(cex)) cex <- 1
    
    if(inherits(data,"IT2B")){
      
      #internal ellipse function from package mixtools
      ellipse <- function(mu,sigma,alpha = 0.05,npoints=250,newplot=FALSE,draw=TRUE, ...) 
      {
        es <- eigen(sigma)
        e1 <- es$vec %*% diag(sqrt(es$val))
        r1 <- sqrt(qchisq(1 - alpha, 2))
        theta <- seq(0, 2 * pi, len = npoints)
        v1 <- cbind(r1 * cos(theta), r1 * sin(theta))
        pts = t(mu - (e1 %*% t(v1)))
        if (newplot && draw) {
          plot(pts, ...)
        }
        else if (!newplot && draw) {
          lines(pts, ...)
        }
        invisible(pts)
      }
      ell <- array(NA,dim=c(length(probs),250,2))
      for(i in 1:length(probs)){
        ell[i,,] <- ellipse(mu=c(data$popMean[xCol],data$popMean[yCol]),sigma=data$popCov[c(xCol,yCol),c(xCol,yCol)],type="l",alpha=probs[i],draw=F)
      }
      graycols <- rev(gray.colors(n=length(probs),start=0,end=0.9))
      if(missing(xlim)) xlim <- range(ell[,,1])
      if(missing(ylim)) ylim <- range(ell[,,2])
      if(missing(col)) col="white"
      if(!missing(legend)){        
        if(class(legend)=="list"){
          legend$plot<- T
          if(is.null(legend$x)) legend$x <- "topright"
          if(is.null(legend$fill)) legend$fill <- graycols
          if(is.null(legend$legend)) legend$legend <- 1-probs
          if(is.null(legend$title)) legend$title <- "Quantile"
        } else {
          if(legend) legend <- {list(plot=T,x="topright",legend=1-probs,fill=graycols,title="Quantile")} else {legend <- list(plot=F)}
        }
      } else {legend <- list(plot=F)}
      
      plot(NA,cex.lab=cex.lab,xlim=xlim,ylim=ylim,type="n",xlab=xlab,ylab=ylab,...)
      
      
      for(i in 1:length(probs)){
        polygon(ell[i,,],col=graycols[i],lwd=lwd)
      }
      if(grid) abline(v=c(axTicks(1),diff(axTicks(1))/2 + axTicks(1)[-length(axTicks(1))]),h=c(axTicks(2),diff(axTicks(2))/2 + axTicks(2)[-length(axTicks(2))]),col="lightgrey")
      points(x=data$popMean[xCol],y=data$popMean[yCol],pch=pch,col=col,cex=cex,lwd=lwd,...)
      if(legend$plot) do.call("legend",legend)
    }    
    if(inherits(data,"NPAG")){
      if(missing(bg)) bg <- "gray50"
      if(missing(col)) col <- "white"
      x <- model.frame(formula=formula,data=data$popPoints)[2][,1]
      y <- model.frame(formula=formula,data=data$popPoints)[1][,1]
      z <- data$popPoints[,"prob"]
      if(missing(xlim)) xlim <- range(x)
      if(missing(ylim)) ylim <- range(y)
      plot(y=y,x=x,pch=21,bg=bg,cex=scale*z,xlab=xlab,ylab=ylab,lwd=lwd,cex.lab=cex.lab,xlim=xlim,ylim=ylim,...)
      points(y=y,x=x,pch=pch,col=col,cex=cex,lwd=lwd,...)
      if(grid) abline(v=c(axTicks(1),diff(axTicks(1))/2 + axTicks(1)[-length(axTicks(1))]),h=c(axTicks(2),diff(axTicks(2))/2 + axTicks(2)[-length(axTicks(2))]),col="lightgrey")
      
    }
    
    
  }
  #close device if necessary
  if(inherits(out,"list")) dev.off()
  
  return(invisible(1))
}
